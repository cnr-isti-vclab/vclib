/*****************************************************************************
 * VCLib                                                                     *
 * Visual Computing Library                                                  *
 *                                                                           *
 * Copyright(C) 2021-2026                                                    *
 * Visual Computing Lab                                                      *
 * ISTI - Italian National Research Council                                  *
 *                                                                           *
 * All rights reserved.                                                      *
 *                                                                           *
 * This program is free software; you can redistribute it and/or modify      *
 * it under the terms of the Mozilla Public License Version 2.0 as published *
 * by the Mozilla Foundation; either version 2 of the License, or            *
 * (at your option) any later version.                                       *
 *                                                                           *
 * This program is distributed in the hope that it will be useful,           *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              *
 * Mozilla Public License Version 2.0                                        *
 * (https://www.mozilla.org/en-US/MPL/2.0/) for more details.                *
 ****************************************************************************/

#ifndef VCL_EMBREE_SCENE_H
#define VCL_EMBREE_SCENE_H

#include <embree4/rtcore.h>

#include <vclib/algorithms/mesh.h>
#include <vclib/mesh.h>
#include <vclib/space/complex.h>

namespace vcl::embree {

class Scene
{
    RTCDevice mDevice = rtcNewDevice(nullptr);
    RTCScene  mScene  = rtcNewScene(mDevice);

    TriPolyIndexBiMap mIndexMap;

public:
    /**
     * @brief The type representing the result of a hit test.
     *
     * The tuple contains:
     * - the id of the (polygonal) face that has been hit
     * - the barycentric coordinates of the hit point
     * - the id of the (triangulated) triangle that has been hit within
     *   the face (from 0 to number of triangles generated by the polygon; will
     *   be always 0 for triangular faces only)
     *
     * If no face is hit, the first element of the tuple is UINT_NULL.
     *
     * If the Mesh in the scene is triangulated, the third element can be
     * ignored. If the Mesh in the scene is polygonal, the baricentric coords
     * refer to the triangle within the polygon that has been hit, so the third
     * element is needed to identify the exact triangle within the polygon.
     * The list of triangles within each polygon is defined by the triangulation
     * generated by the function @ref vcl::earCut.
     */
    using HitResult = std::tuple<uint, Point3f, uint>;

    Scene() = default;

    ~Scene()
    {
        rtcReleaseScene(mScene);
        rtcReleaseDevice(mDevice);
    }

    template<FaceMeshConcept MeshType>
    Scene(const MeshType& m)
    {
        // TODO: manage RAII here

        RTCGeometry geometry =
            rtcNewGeometry(mDevice, RTC_GEOMETRY_TYPE_TRIANGLE);

        float* vb = (float*) rtcSetNewGeometryBuffer(
            geometry,
            RTC_BUFFER_TYPE_VERTEX,
            0,
            RTC_FORMAT_FLOAT3,
            3 * sizeof(float),
            m.vertexNumber());

        vertexPositionsToBuffer(m, vb);

        uint numTris = vcl::countTriangulatedTriangles(m);

        uint* ib = (uint*) rtcSetNewGeometryBuffer(
            geometry,
            RTC_BUFFER_TYPE_INDEX,
            0,
            RTC_FORMAT_UINT3,
            3 * sizeof(unsigned),
            numTris);

        triangulatedFaceVertexIndicesToBuffer(
            m, ib, mIndexMap, MatrixStorageType::ROW_MAJOR, numTris);

        rtcCommitGeometry(geometry);
        rtcAttachGeometry(mScene, geometry);

        rtcReleaseGeometry(geometry);

        rtcCommitScene(mScene);
    }

    // delete copy constructor and copy assignment operator
    Scene(const Scene&) = delete;
    Scene& operator=(const Scene&) = delete;

    // move constructor
    Scene(Scene&& other) noexcept
    {
        swap(other);
    }

    // move assignment operator
    Scene& operator=(Scene&& other) noexcept
    {
        swap(other);
        return *this;
    }

    void swap(Scene& other)
    {
        using std::swap;
        swap(mDevice, other.mDevice);
        swap(mScene, other.mScene);
    }

    friend void swap(Scene& a, Scene& b) { a.swap(b); }

    template<typename ScalarType>
    HitResult firstFaceIntersectedByRay(
        const Point3<ScalarType>& origin,
        const Point3<ScalarType>& direction,
        float near = 0.f,
        float far = std::numeric_limits<float>::infinity()) const
    {
        RTCRayHit rayhit = initRayHitValues(origin, direction, near, far);

        rtcIntersect1(mScene, &rayhit);

        if (rayhit.hit.geomID != RTC_INVALID_GEOMETRY_ID) {
            uint    fID = mIndexMap.polygon(rayhit.hit.primID);
            float   w   = 1.f - rayhit.hit.u - rayhit.hit.v;
            Point3f barycentricCoords(w, rayhit.hit.u, rayhit.hit.v);
            uint    triID = rayhit.hit.primID - mIndexMap.triangleBegin(fID);
            return std::make_tuple(fID, barycentricCoords, triID);
        }
        else {
            return std::make_tuple(UINT_NULL, Point3f(), uint(0));
        }
    }

    template<typename ScalarType>
    HitResult firstFaceIntersectedByRay(
        const Ray3<ScalarType>& ray,
        float near = 0.f,
        float far = std::numeric_limits<float>::infinity()) const
    {
        return firstFaceIntersectedByRay(
            ray.origin(), ray.direction(), near, far);
    }

    template<typename ScalarType>
    HitResult firstFaceIntersectedBySegment(
        const Segment3<ScalarType>& segment) const
    {
        return firstFaceIntersectedByRay(
            segment.p0(), segment.direction(), 0.f, segment.length());
    }

    template<Range R>
    std::vector<HitResult> firstFaceIntersectedByRays(
        R&&   origins,
        R&&   directions,
        float near = 0.f,
        float far  = std::numeric_limits<float>::infinity()) const
        requires Point3Concept<std::ranges::range_value_t<R>>
    {
        using PointType  = std::ranges::range_value_t<R>;
        using ScalarType = typename PointType::ScalarType;

        assert(std::ranges::size(origins) == std::ranges::size(directions) &&
               "Origins and directions ranges must have the same size.");

        std::size_t sz = std::ranges::size(origins);

        std::vector<HitResult> results(sz);

        std::size_t chunks = sz / 16;
        std::size_t rem    = sz % 16;

        if (rem != 0) {
            ++chunks;
        }

        auto computeChunk = [&](uint chunk) {
            std::array<int, 16> validMask;
            std::ranges::fill(validMask, -1);

            RTCRayHit16 rayHits;

            std::size_t first = chunk * 16;
            std::size_t last  = first + 16;
            if (last > sz) {
                for (std::size_t i = sz % 16; i < 16; ++i) {
                    validMask[i] = 0;
                }
                last = sz;
            }


            for (std::size_t i = first; i < last; ++i) {

                std::size_t idx = i - first;
                initRayHitsValues(
                    rayHits,
                    idx,
                    origins[i],
                    directions[i],
                    near,
                    far);
            }

            rtcIntersect16(validMask.data(), mScene, &rayHits);

            for (std::size_t i = first; i < last; ++i) {
                std::size_t idx = i - first;
                if (rayHits.hit.geomID[idx] != RTC_INVALID_GEOMETRY_ID) {
                    uint    fID = mIndexMap.polygon(rayHits.hit.primID[idx]);
                    float   w   = 1.f - rayHits.hit.u[idx] - rayHits.hit.v[idx];
                    Point3f barycentricCoords(
                        w, rayHits.hit.u[idx], rayHits.hit.v[idx]);
                    uint triID =
                        rayHits.hit.primID[idx] - mIndexMap.triangleBegin(fID);
                    results[i] = std::make_tuple(fID, barycentricCoords, triID);
                }
                else {
                    results[i] = std::make_tuple(UINT_NULL, Point3f(), uint(0));
                }
            }
        };

        std::vector<std::size_t> chunkIndices(chunks);
        std::iota(chunkIndices.begin(), chunkIndices.end(), 0);

        vcl::parallelFor(chunkIndices, computeChunk);

        return results;
    }

private:
    template<Point3Concept PointType>
    static inline RTCRayHit initRayHitValues(
        const PointType& origin,
        const PointType& direction,
        float            tnear = 0.f,
        float            tfar = std::numeric_limits<float>::infinity())
    {
        RTCRayHit rayhit;
        rayhit.ray.org_x     = origin.x();
        rayhit.ray.org_y     = origin.y();
        rayhit.ray.org_z     = origin.z();
        rayhit.ray.dir_x     = direction.x();
        rayhit.ray.dir_y     = direction.y();
        rayhit.ray.dir_z     = direction.z();
        rayhit.ray.tnear     = tnear;
        rayhit.ray.tfar      = tfar;
        rayhit.ray.mask      = -1;
        rayhit.ray.flags     = 0;
        rayhit.hit.geomID    = RTC_INVALID_GEOMETRY_ID;
        rayhit.hit.instID[0] = RTC_INVALID_GEOMETRY_ID;
        return rayhit;
    }

    template<Point3Concept PointType>
    static inline void initRayHitsValues(
        RTCRayHit16&     rayhits,
        uint i,
        const PointType& origin,
        const PointType& direction,
        float            tnear = 0.f,
        float            tfar = std::numeric_limits<float>::infinity())
    {
        rayhits.ray.org_x[i]     = origin.x();
        rayhits.ray.org_y[i]     = origin.y();
        rayhits.ray.org_z[i]     = origin.z();
        rayhits.ray.dir_x[i]     = direction.x();
        rayhits.ray.dir_y[i]     = direction.y();
        rayhits.ray.dir_z[i]     = direction.z();
        rayhits.ray.tnear[i]     = tnear;
        rayhits.ray.tfar[i]      = tfar;
        rayhits.ray.mask[i]      = -1;
        rayhits.ray.flags[i]     = 0;
        rayhits.hit.geomID[i]    = RTC_INVALID_GEOMETRY_ID;
        rayhits.hit.instID[0][i] = RTC_INVALID_GEOMETRY_ID;
    }
};

} // namespace vcl::embree

#endif // VCL_EMBREE_SCENE_H
