/*****************************************************************************
 * VCLib                                                                     *
 * Visual Computing Library                                                  *
 *                                                                           *
 * Copyright(C) 2021-2026                                                    *
 * Visual Computing Lab                                                      *
 * ISTI - Italian National Research Council                                  *
 *                                                                           *
 * All rights reserved.                                                      *
 *                                                                           *
 * This program is free software; you can redistribute it and/or modify      *
 * it under the terms of the Mozilla Public License Version 2.0 as published *
 * by the Mozilla Foundation; either version 2 of the License, or            *
 * (at your option) any later version.                                       *
 *                                                                           *
 * This program is distributed in the hope that it will be useful,           *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              *
 * Mozilla Public License Version 2.0                                        *
 * (https://www.mozilla.org/en-US/MPL/2.0/) for more details.                *
 ****************************************************************************/

#ifndef VCL_EMBREE_SCENE_H
#define VCL_EMBREE_SCENE_H

#include <embree4/rtcore.h>

#include <vclib/algorithms/mesh.h>
#include <vclib/mesh.h>
#include <vclib/space/complex.h>

namespace vcl::embree {

/**
 * @brief Wrapper around an Embree scene for mesh intersection queries.
 *
 * This class manages an internal Embree ::RTCDevice and ::RTCScene and
 * exposes a high-level interface to perform rayâ€“mesh intersection queries
 * on VCLib meshes. A scene is typically constructed from a mesh object
 * satisfying the @ref FaceMeshConcept and then queried using
 * @ref firstFaceIntersectedByRay or @ref firstFaceIntersectedByRays to
 * obtain the first intersected face, barycentric coordinates of the hit
 * point, and the local triangle index within polygonal faces.
 *
 * All rays passed to the intersection methods are assumed to be expressed
 * in the same coordinate system and units as the mesh used to build the
 * scene. The mapping between Embree's internal triangle indices and the
 * original mesh faces is handled internally via @ref TriPolyIndexBiMap.
 *
 * A Scene object is non-copyable but movable.
 */
class Scene
{
    RTCDevice mDevice = nullptr;
    RTCScene  mScene  = nullptr;

    TriPolyIndexBiMap mIndexMap;

public:
    /**
     * @brief The type representing the result of a hit test.
     *
     * The tuple contains:
     * - the id of the (polygonal) face that has been hit
     * - the barycentric coordinates of the hit point
     * - the id of the (triangulated) triangle that has been hit within
     *   the face (from 0 to number of triangles generated by the polygon; will
     *   be always 0 for triangular faces only)
     *
     * If no face is hit, the first element of the tuple is UINT_NULL.
     *
     * If the Mesh in the scene is triangulated, the third element can be
     * ignored. If the Mesh in the scene is polygonal, the barycentric coords
     * refer to the triangle within the polygon that has been hit, so the third
     * element is needed to identify the exact triangle within the polygon.
     * The list of triangles within each polygon is defined by the triangulation
     * generated by the function @ref vcl::earCut.
     */
    using HitResult = std::tuple<uint, Point3f, uint>;

    Scene() = default;

    ~Scene()
    {
        if (mScene)
            rtcReleaseScene(mScene);
        if (mDevice)
            rtcReleaseDevice(mDevice);
    }

    /**
     * @brief Constructs an Embree scene from a mesh.
     *
     * This constructor initializes an Embree device and scene, creates a
     * triangle geometry from the vertices and faces of the given mesh, and
     * attaches it to the internal Embree scene. The mesh is internally
     * triangulated, and a mapping between triangulated faces and the original
     * polygonal faces is stored in the index map.
     *
     * @tparam MeshType: A mesh type that satisfies the @ref FaceMeshConcept
     * and provides vertex positions and face connectivity compatibl with the
     * functions used to fill the Embree buffers.
     *
     * @param[in] m: The input mesh whose geometry is used to build the Embree
     * acceleration structure.
     *
     * @throws std::runtime_error if the Embree device, scene, or geometry
     * cannot be created or initialized.
     */
    template<FaceMeshConcept MeshType>
    Scene(const MeshType& m)
    {
        mDevice = rtcNewDevice(nullptr);

        if (!mDevice)
            throw std::runtime_error("Error creating Embree device.");

        mScene = rtcNewScene(mDevice);

        if (!mScene) {
            rtcReleaseDevice(mDevice);
            throw std::runtime_error("Error creating Embree scene.");
        }

        RTCGeometry geometry =
            rtcNewGeometry(mDevice, RTC_GEOMETRY_TYPE_TRIANGLE);

        if (!geometry) {
            rtcReleaseScene(mScene);
            rtcReleaseDevice(mDevice);
            throw std::runtime_error("Error creating Embree geometry.");
        }

        float* vb = (float*) rtcSetNewGeometryBuffer(
            geometry,
            RTC_BUFFER_TYPE_VERTEX,
            0,
            RTC_FORMAT_FLOAT3,
            3 * sizeof(float),
            m.vertexNumber());

        vertexPositionsToBuffer(m, vb);

        uint numTris = vcl::countTriangulatedTriangles(m);

        uint* ib = (uint*) rtcSetNewGeometryBuffer(
            geometry,
            RTC_BUFFER_TYPE_INDEX,
            0,
            RTC_FORMAT_UINT3,
            3 * sizeof(unsigned),
            numTris);

        triangulatedFaceVertexIndicesToBuffer(
            m, ib, mIndexMap, MatrixStorageType::ROW_MAJOR, numTris);

        rtcCommitGeometry(geometry);
        rtcAttachGeometry(mScene, geometry);

        rtcReleaseGeometry(geometry);

        rtcCommitScene(mScene);
    }

    // delete copy constructor and copy assignment operator
    Scene(const Scene&)            = delete;
    Scene& operator=(const Scene&) = delete;

    // move constructor
    Scene(Scene&& other) noexcept { swap(other); }

    // move assignment operator
    Scene& operator=(Scene&& other) noexcept
    {
        swap(other);
        return *this;
    }

    void swap(Scene& other)
    {
        using std::swap;
        swap(mDevice, other.mDevice);
        swap(mScene, other.mScene);
        swap(mIndexMap, other.mIndexMap);
    }

    friend void swap(Scene& a, Scene& b) { a.swap(b); }

    /**
     * @brief Finds the first face intersected by a ray.
     *
     * This member function casts a ray from the given origin in the specified
     * direction and returns the first face of the scene that is intersected
     * within the given near and far distances.
     *
     * @tparam ScalarType: Scalar type used by the point coordinates
     * (for example, float or double).
     *
     * @param[in] origin: The origin point of the ray in world space.
     * @param[in] direction: The direction vector of the ray in world space.
     * @param[in] near: The minimum distance from the origin to consider for
     * intersections (default is 0).
     * @param[in] far: The maximum distance from the origin to consider for
     * intersections (default is infinity).
     *
     * @return A HitResult describing the first intersected face along the
     * ray. If no face is intersected, the first element of the returned tuple
     * is UINT_NULL.
     */
    template<typename ScalarType>
    HitResult firstFaceIntersectedByRay(
        const Point3<ScalarType>& origin,
        const Point3<ScalarType>& direction,
        float                     near = 0.f,
        float far = std::numeric_limits<float>::infinity()) const
    {
        if (mScene) {
            RTCRayHit rayhit = initRayHitValues(origin, direction, near, far);

            rtcIntersect1(mScene, &rayhit);

            if (rayhit.hit.geomID != RTC_INVALID_GEOMETRY_ID) {
                uint    fID = mIndexMap.polygon(rayhit.hit.primID);
                float   w   = 1.f - rayhit.hit.u - rayhit.hit.v;
                Point3f barycentricCoords(w, rayhit.hit.u, rayhit.hit.v);
                uint triID = rayhit.hit.primID - mIndexMap.triangleBegin(fID);
                return std::make_tuple(fID, barycentricCoords, triID);
            }
        }

        return std::make_tuple(UINT_NULL, Point3f(), uint(0));
    }

    /**
     * @brief Finds the first face intersected by a ray.
     *
     * This member function casts the given ray and returns the first face of
     * the scene that is intersected within the given near and far distances.
     *
     * @tparam ScalarType: Scalar type used by the ray coordinates
     * (for example, float or double).
     *
     * @param[in] ray: The ray in world space used as query.
     * @param[in] near: The minimum distance from the ray origin to consider
     * for intersections (default is 0).
     * @param[in] far: The maximum distance from the ray origin to consider
     * for intersections (default is infinity).
     *
     * @return A HitResult describing the first intersected face along the
     * ray. If no face is intersected, the first element of the returned tuple
     * is UINT_NULL.
     */
    template<typename ScalarType>
    HitResult firstFaceIntersectedByRay(
        const Ray3<ScalarType>& ray,
        float                   near = 0.f,
        float far = std::numeric_limits<float>::infinity()) const
    {
        return firstFaceIntersectedByRay(
            ray.origin(), ray.direction(), near, far);
    }

    /**
     * @brief Finds the first face intersected by a segment.
     *
     * This member function casts a ray along the given segment and returns the
     * first face of the scene that is intersected within the finite extent of
     * the segment, i.e. between its two endpoints.
     *
     * @tparam ScalarType: Scalar type used by the segment coordinates
     * (for example, float or double).
     *
     * @param[in] segment: The segment in world space used as query; only
     * intersections occurring between segment.p0() and segment.p1() are
     * considered.
     *
     * @return A HitResult describing the first intersected face along the
     * segment (closest to segment.p0()). If no face is intersected, the first
     * element of the returned tuple is UINT_NULL.
     */
    template<typename ScalarType>
    HitResult firstFaceIntersectedBySegment(
        const Segment3<ScalarType>& segment) const
    {
        return firstFaceIntersectedByRay(
            segment.p0(), segment.direction(), 0.f, segment.length());
    }

    /**
     * @brief Finds the first faces intersected by multiple rays.
     *
     * This member function casts multiple rays defined by the given origins and
     * directions, and returns for each ray the first face of the scene that
     * is intersected within the given near and far distances.
     *
     * This function performs ray intersection tests in parallel to improve
     * performance when dealing with a large number of rays.
     *
     * @tparam R1: A random access range type whose elements satisfy the
     * @ref Point3Concept, representing the ray origins.
     * @tparam R2: A random access range type whose elements satisfy the
     * @ref Point3Concept, representing the ray directions.
     *
     * @param[in] origins: A range of points representing the origins of the
     * rays in world space.
     * @param[in] directions: A range of vectors representing the directions
     * of the rays in world space.
     * @param[in] near: The minimum distance from each ray origin to consider
     * for intersections (default is 0).
     * @param[in] far: The maximum distance from each ray origin to consider
     * for intersections (default is infinity).
     *
     * @return A vector of HitResult tuples, one for each ray, describing the
     * first intersected face along each ray. If a ray does not intersect any
     * face, the first element of the corresponding tuple is UINT_NULL.
     */
    template<RandomAccessRange R1, RandomAccessRange R2>
    std::vector<HitResult> firstFaceIntersectedByRays(
        R1&&  origins,
        R2&&  directions,
        float near = 0.f,
        float far  = std::numeric_limits<float>::infinity()) const
        requires Point3Concept<std::ranges::range_value_t<R1>> &&
                 Point3Concept<std::ranges::range_value_t<R2>>
    {
        using PointType  = std::ranges::range_value_t<R1>;
        using ScalarType = typename PointType::ScalarType;

        assert(
            std::ranges::size(origins) == std::ranges::size(directions) &&
            "Origins and directions ranges must have the same size.");

        std::size_t sz = std::ranges::size(origins);

        std::vector<HitResult> results(sz);

        if (mScene) {
            // some cpus fail to guarantee thread safety for rtcIntersect16
#ifndef VCL_EMBREE_FORCE_CHUNK_16
            auto computeRay = [&](uint i) {
                results[i] = firstFaceIntersectedByRay(
                    origins[i], directions[i], near, far);
            };

            std::vector<std::size_t> rayIndices(sz);
            std::iota(rayIndices.begin(), rayIndices.end(), 0);

            vcl::parallelFor(rayIndices, computeRay);
#else
            std::size_t chunks = sz / 16;
            std::size_t rem    = sz % 16;

            if (rem != 0) {
                ++chunks;
            }

            auto computeChunk = [&](uint chunk) {
                std::array<int, 16> validMask;
                std::ranges::fill(validMask, -1);

                RTCRayHit16 rayHits;

                std::size_t first = chunk * 16;
                std::size_t last  = first + 16;
                if (last > sz) {
                    for (std::size_t i = sz % 16; i < 16; ++i) {
                        validMask[i] = 0;
                    }
                    last = sz;
                }

                for (std::size_t i = first; i < last; ++i) {
                    std::size_t idx = i - first;
                    initRayHitsValues(
                        rayHits, idx, origins[i], directions[i], near, far);
                }

                rtcIntersect16(validMask.data(), mScene, &rayHits);

                for (std::size_t i = first; i < last; ++i) {
                    std::size_t idx = i - first;
                    if (rayHits.hit.geomID[idx] != RTC_INVALID_GEOMETRY_ID) {
                        uint  fID = mIndexMap.polygon(rayHits.hit.primID[idx]);
                        float w = 1.f - rayHits.hit.u[idx] - rayHits.hit.v[idx];
                        Point3f barycentricCoords(
                            w, rayHits.hit.u[idx], rayHits.hit.v[idx]);
                        uint triID = rayHits.hit.primID[idx] -
                                     mIndexMap.triangleBegin(fID);
                        results[i] =
                            std::make_tuple(fID, barycentricCoords, triID);
                    }
                    else {
                        results[i] =
                            std::make_tuple(UINT_NULL, Point3f(), uint(0));
                    }
                }
            };

            std::vector<std::size_t> chunkIndices(chunks);
            std::iota(chunkIndices.begin(), chunkIndices.end(), 0);

            vcl::parallelFor(chunkIndices, computeChunk);
#endif
        }
        else {
            std::fill(
                results.begin(),
                results.end(),
                std::make_tuple(UINT_NULL, Point3f(), uint(0)));
        }

        return results;
    }

    /**
     * @brief Finds the first faces intersected by multiple rays.
     *
     * This member function casts multiple rays and returns for each ray the
     * first face of the scene that is intersected within the given near and
     * far distances.
     *
     * This function performs ray intersection tests in parallel to improve
     * performance when dealing with a large number of rays.
     *
     * @tparam R: A random access range type whose elements satisfy the
     * @ref Ray3Concept, representing the rays to be tested.
     *
     * @param[in] rays: A range of rays in world space used as queries.
     * @param[in] near: The minimum distance from each ray origin to consider
     * for intersections (default is 0).
     * @param[in] far: The maximum distance from each ray origin to consider
     * for intersections (default is infinity).
     *
     * @return A vector of HitResult tuples, one for each ray, describing the
     * first intersected face along each ray. If a ray does not intersect any
     * face, the first element of the corresponding tuple is UINT_NULL.
     */
    template<RandomAccessRange R>
    std::vector<HitResult> firstFaceIntersectedByRays(
        R&&   rays,
        float near = 0.f,
        float far  = std::numeric_limits<float>::infinity()) const
        requires Ray3Concept<std::ranges::range_value_t<R>>
    {
        auto getOriginView = [](const auto& r) {
            return r.origin();
        };

        auto getDirectionView = [](const auto& r) {
            return r.direction();
        };

        auto origins    = rays | std::views::transform(getOriginView);
        auto directions = rays | std::views::transform(getDirectionView);

        return firstFaceIntersectedByRays(origins, directions, near, far);
    }

private:
    template<Point3Concept PointType>
    static inline RTCRayHit initRayHitValues(
        const PointType& origin,
        const PointType& direction,
        float            tnear = 0.f,
        float            tfar  = std::numeric_limits<float>::infinity())
    {
        RTCRayHit rayhit;
        rayhit.ray.org_x     = origin.x();
        rayhit.ray.org_y     = origin.y();
        rayhit.ray.org_z     = origin.z();
        rayhit.ray.dir_x     = direction.x();
        rayhit.ray.dir_y     = direction.y();
        rayhit.ray.dir_z     = direction.z();
        rayhit.ray.tnear     = tnear;
        rayhit.ray.tfar      = tfar;
        rayhit.ray.mask      = -1;
        rayhit.ray.flags     = 0;
        rayhit.hit.geomID    = RTC_INVALID_GEOMETRY_ID;
        rayhit.hit.instID[0] = RTC_INVALID_GEOMETRY_ID;
        return rayhit;
    }

    template<Point3Concept PointType>
    static inline void initRayHitsValues(
        RTCRayHit16&     rayhits,
        uint             i,
        const PointType& origin,
        const PointType& direction,
        float            tnear = 0.f,
        float            tfar  = std::numeric_limits<float>::infinity())
    {
        rayhits.ray.org_x[i]     = origin.x();
        rayhits.ray.org_y[i]     = origin.y();
        rayhits.ray.org_z[i]     = origin.z();
        rayhits.ray.dir_x[i]     = direction.x();
        rayhits.ray.dir_y[i]     = direction.y();
        rayhits.ray.dir_z[i]     = direction.z();
        rayhits.ray.tnear[i]     = tnear;
        rayhits.ray.tfar[i]      = tfar;
        rayhits.ray.mask[i]      = -1;
        rayhits.ray.flags[i]     = 0;
        rayhits.hit.geomID[i]    = RTC_INVALID_GEOMETRY_ID;
        rayhits.hit.instID[0][i] = RTC_INVALID_GEOMETRY_ID;
    }
};

} // namespace vcl::embree

#endif // VCL_EMBREE_SCENE_H
